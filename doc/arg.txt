** Argument Function

$Id: arg.txt,v 1.7 2004-02-18 13:35:04 oops Exp $


변수 관련 high level 함수이다.


char ** argv_make ( char * stream, int *argc )

    문자열을 공백문자를 기준으로 배열로 변환을 한다. 쉽게 command line 의
    명령행이 argv 변수로 되는 것과 동일하게 생각할 수 있다.

    stream 은 입력할 문자열을 지정하며, argc 는 생성된 배열의 수가 반환이
    된다.

    생성된 배열은 ofree_array 함수로 메모리 해제를 해 주어야 한다.

    ex) #include <olibc/libarg.h>

        char * string = "arg1 arg2 arg3 \"arg4 arg5\"";
        char ** argv;
        char ** scan;
        int argc, i;

        argv = argv_make (string, &argc);

        printf ("## 생성된 배열의 수 : %d\n", argc);

        for ( scan = argv, i=0; *scan != NULL; scan++, i++ ) {
          printf ("[%d] %s\n", *scan);
        }

        ofree_array (argv);

    저작권: BPL License v.1 <http://devel.oops.org/document/bpl>


char ** split ( char * stream, int *argc, char *delimiter )

    문자열을 주어진 delimiter 에 의해서 배열로 반환한다. delimiter 는 문자
    열로 지정을 하며, 지정된 문자열은 charactor 단위로 문자열을 쪼개게 된다.
    이는 delimiter 가 'ab' 로 지정이 되었을 경우 'ab' 로 쪼개는 것이 아니라
    'a' 또는 'b' 로 쪼개는 것을 의미한다.

    또한, 주어진 문자열 중, delimiter 에 지정된 charactor 과 매치가 되는 글
    자가 있더라도 매치가 되는 글자 앞에 '\' 가 있을 경우에는 무시가 된다.

    stream 은 원본 문자열을 지정한다.
    argc 는 생성된 배열의 수를 반환한다.
    delimiter 는 배열로 구분할 문자열을 지정한다.

    생성된 배열은 반드시 ofree_array 함수로 메모리 해제를 해 주어야 한다.
    stream 이나 delimiter 가 주어지지 않을 경우 NULL 을 반환한다.

    ex) #include <olibc/libarg.h>

        char ** sep;
        char *a = "abcAabcAabc";
        int i, j;

        sep = split (files, &i, "A");

        for (j = 0; j < i; j++) {
          printf ("** %s\n", sep[i]);
        }
     
        ofree_array (sep);

    저작권: BPL License v.1 <http://devel.oops.org/document/bpl>


void ofree_array ( char **array )

    메모리가 할당된 배열에 대해서 메모리를 해제 시킨다. 이 함수를 사용하기
    위해서는 마지막 배열이 NULL 값을 가지고 있어야 한다.

    ex) argv_make 함수 참조

    저작권: BPL License v.1 <http://devel.oops.org/document/bpl>


int get_whitespace ( char * string )

    문자열에 포함이 되어 있는 white space 문자 수를 반환한다.

    ex) #include <olibc/libarg.h>

        char * string = "a b c d e	f";

        printf ("## %d\n", get_whitespace (string));

    저작권: BPL License v.1 <http://devel.oops.org/document/bpl>


int o_getopt ( int argc, char **argv, const char *opt, const struct o_option, *longopt)

    command line 에서 넘어온 문자열을 getopt 함수와 유사하게 분석을 한다.
    o_getop 함수는 short 형 옵션과 long 형 옵션을 모두 지원을 하며, 이 함수를 사용하고
    난 후에는 command line 에서 넘어온 문자열에서 옵션에 해당하는 부분을 제외한 나머지
    값들이 차례로 o_cmdarg 배열 변수에 남게 된다.

    이 함수는 o_optarg, o_optlen, o_cmdarg, _ogetopt_cmd_int, _ogetopt_chk_int 의 전역
    변수를 생성/사용하게 된며, 이 함수를 사용하기 전에는

    _ogetopt_cmd_int = 0;
    _ogetopt_chk_int = -1;

    두 변수를 초기화 해 줘야 한다.

    이 함수를 사용한 후에는 ofree_array 함수로 o_cmdarg 배열 변수를 메모리 해제해 줘야
    한다.

    o_optarg 는 해당 옵션의 값을 받게 되며 1024 이상의 문자열은 잘라진다.  o_optlen 은
    o_optarg 의 길이를 가지게 된다. o_cmdarg 변수는 argv[0] 과 옵션/옵션값에 해당 되는
    문자열만 제외하고, 나머지 명령행들을 공백문자로 분리하여 배열로 가지게 된다.

    o_cmdarg 배열의 수는 _ogetopt_cmd_int 에 저장이 된다.



    이 함수에서 사용하는 변수들은 다음과 같다.

    argc 는 명령행에서 넘어온 argv 배열의 갯수를 지정한다.

    argv 는 명령행에서 넘어온 argv 배열을 지정한다.

    opt 는 명령행에서 넘어온 argv 에서 옵션과 그 값을 체크하는 문자열을 가지게 된다.
    opt 는 문자열로, 사용할 각 옵션을 문자열로 나열을 하며,  옵션의 값이 필요한 경우에
    는 옵션 문자 뒤에 ':' 문자를 붙이도록 한다. 예를들어 a, b, c 라는 옵션을 사용을 하
    려고 하고, b 옵션의 경우 값이 있어야 한다면, opt 변수는 다음과 같이 지정이 된다.

    o_getopt (argc, argv, "ab:c", NULL);

    longopt 는 opt 가 shot 형의 옵션을 지정하는 것에 반하여, longopt 는 long 형의 옵션
    을 정의한 struct 를 지정한다.

    longopt 의 struct 구조는 다음과 같다.

        struct o_option {
             char *name;     // long 옵션 이름
             int required    // 옵션의 값이 있어야 하는지 여부
             int value       // long 옵션과 대응될 shot 옵션
        };


    예를 들어, -b 옵션이 옵션값이 필요하고, long 옵션 --best 를 -b 에 매치할 경우에는

    strcut o_option longopt[] = { 
      { "best", required_arguments, 'b' }
    };

    와 같이 지정이 된다. 가운데의 required_arguments 는 옵션의 값이 있어야 한다는 것이
    며, 이를 위해 사용되는 상수는 requried_arguments 와 no_arguments 가 있다.
    
    long option 을 사용하지 않으려면

    o_getopt (argc, argv, "ab:c", NULL);

    과 같이 사용할 수 있으며, 사용을 하려면, longopt struct 를 정의한 다음

    o_getopt (argc, argv, "ab:c", longopt);

    와 같이 지정을 한다.

    o_getopt 의 리턴값이 -1 일 경우에는 파싱이 종료됨을 의미한다.

    주의할 것은 loop 문 안에서 o_geopt 의 반환값 0 (명령행 인자일 경우의 리턴값) 에 대
    한 부분을 처리해야 한다.


    ex)

        명령행이

        /usr/bin/parse_getopt -a arg1 -b log

        이며 -b 옵션은 따로 옵션 값이 없을 경우의 예를 든다.  이 명령행을 long 형 옵션
        으로 사용할 경우에는

        /usr/bin/parse_getopt --append=arg1 --best log 또는
        /usr/bin/parse_getopt --append arg1 --best log 

        과 같이 사용할 경우이다. long 옵션의 값은 '=' 문자로 정의할 수 있으며, 또는 공
        백 문자로 정의할 수 있다.


        #include <olibc/libarg.h>

        int main (int argc, char **argv) {
            int opt;
            char app[1024];
            int  bestopt = 0;

            static struct o_option longopt[] = {
                { "append", required_arguments, 'a' },
                { "best", no_arguments, 'b' },
                { 0, 0, 0 }
            };

            /* 안해줘도 괜찮지만, 해 주는 것이 좋다. */
            _ogetopt_cmd_int = 0;
            _ogetopt_chk_int = -1;

            /* 옵션 값을 파싱 */
            while ( (opt = o_getopt (argc, argv, "a:b", longopt)) != -1 ) {
               switch (opt) {
                   case 'a' :
                      if ( o_optlen > 0 ) {
                          strcpy (app, o_optarg);
                      } else {
                          fprintf (stderr, "no argument with -%c option\n", opt);
                      }
                      break;
                   case 'b' :
                      bestopt = 1;
                      break;
                   /* 옵션으로 처리되지 않는 부분의 리턴값은 그냥 통과 시킨다. */
                   case 0 :
                      break;
                   default:
                      fprintf (stderr, "usage: %s [-a optarg|-b] [log|conf]\n", argv[0]);
                      exit (1);
               }
            }

            /* 명령행을 확인 */
            if ( _ogetopt_cmd_int != 1 ) {
                fprintf (stderr, "usage: %s [-a optarg|-b] [log|conf]\n", argv[0]);
                exit (1);
            }

            if ( ! strcmp (o_cmdarg[0], "log") ) {
                ....
            } else if ( ! strcmp (o_cmdarg[0], "conf") ) {
                ...
            } else {
                fprintf (stderr, "usage: %s [-a optarg|-b] [log|conf]\n", argv[0]);
                exit (1);
            }


            /* 꼭 해줘야 한다. */
            ofree_array (o_cmdarg);
        }

    저작권: BPL License v.1 <http://devel.oops.org/document/bpl>

